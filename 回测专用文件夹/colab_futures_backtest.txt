# 在 Colab 或本地均可运行（将下列三段分别粘贴到三个单元格/或依次在终端执行等价命令）

# [单元格 1] 安装依赖（Colab 符号前加 !；本地终端直接运行 pip）
!pip install -q ccxt pandas numpy

# [单元格 2] 用纯 Python 将回测脚本写入 colab_futures_backtest.py（无魔法命令）
script = r'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import ccxt
import pandas as pd
import numpy as np
from datetime import datetime, timezone
from typing import Dict, Any, Callable, Optional, Tuple, List
import re
import os
import glob
from importlib.machinery import SourceFileLoader

# ========= 工具 =========
def _to_series(x: pd.Series) -> pd.Series:
    return x if isinstance(x, pd.Series) else pd.Series(x)

def timeframe_to_minutes(tf: str) -> int:
    m = {
        '1m':1,'3m':3,'5m':5,'15m':15,'30m':30,
        '1h':60,'2h':120,'4h':240,'6h':360,'8h':480,'12h':720,
        '1d':1440
    }
    return m.get(tf, 60)

def parse_symbols_from_file(path: str) -> List[str]:
    if not os.path.exists(path):
        return []
    try:
        text = open(path, 'r', encoding='utf-8', errors='ignore').read()
    except Exception:
        return []
    # 抓取 OKX 合约格式 'BTC-USDT-SWAP'
    symbols = re.findall(r"['\"]([A-Z0-9]+-[A-Z]+-SWAP)['\"]", text)
    seen, ordered = set(), []
    for s in symbols:
        if s not in seen:
            seen.add(s); ordered.append(s)
    return ordered

# ========= 指标（纯 pandas/numpy） =========
def sma(series: pd.Series, window: int) -> pd.Series:
    s = _to_series(series).astype(float)
    return s.rolling(window=window, min_periods=window).mean()

def ema(series: pd.Series, span: int) -> pd.Series:
    s = _to_series(series).astype(float)
    return s.ewm(span=span, adjust=False, min_periods=span).mean()

def macd(series: pd.Series, fast: int = 12, slow: int = 26, signal: int = 9) -> Tuple[pd.Series, pd.Series, pd.Series]:
    s = _to_series(series).astype(float)
    fast_ema = ema(s, fast)
    slow_ema = ema(s, slow)
    macd_line = fast_ema - slow_ema
    signal_line = ema(macd_line, signal)
    hist = macd_line - signal_line
    return macd_line, signal_line, hist

def rsi(series: pd.Series, period: int = 14) -> pd.Series:
    s = _to_series(series).astype(float)
    delta = s.diff()
    gain = delta.clip(lower=0.0)
    loss = (-delta).clip(lower=0.0)
    avg_gain = gain.rolling(window=period, min_periods=period).mean()
    avg_loss = loss.rolling(window=period, min_periods=period).mean().replace(0.0, np.nan)
    rs = avg_gain / avg_loss
    return 100.0 - (100.0 / (1.0 + rs))

def bollinger_bands(series: pd.Series, period: int = 20, std_dev: float = 2.0) -> Tuple[pd.Series, pd.Series, pd.Series]:
    s = _to_series(series).astype(float)
    mid = sma(s, period)
    std = s.rolling(window=period, min_periods=period).std()
    upper = mid + std_dev * std
    lower = mid - std_dev * std
    return upper, mid, lower

def stochastic(high: pd.Series, low: pd.Series, close: pd.Series, k_period: int = 14, d_period: int = 3) -> Tuple[pd.Series, pd.Series]:
    h = _to_series(high).astype(float)
    l = _to_series(low).astype(float)
    c = _to_series(close).astype(float)
    lowest_low = l.rolling(window=k_period, min_periods=k_period).min()
    highest_high = h.rolling(window=k_period, min_periods=k_period).max()
    denom = (highest_high - lowest_low).replace(0.0, np.nan)
    k = (c - lowest_low) / denom * 100.0
    d = k.rolling(window=d_period, min_periods=d_period).mean()
    return k, d

def atr(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> pd.Series:
    h = _to_series(high).astype(float)
    l = _to_series(low).astype(float)
    c = _to_series(close).astype(float)
    prev_close = c.shift(1)
    tr1 = (h - l).abs()
    tr2 = (h - prev_close).abs()
    tr3 = (l - prev_close).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    return tr.rolling(window=period, min_periods=period).mean()

def adx(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14) -> pd.Series:
    h = _to_series(high).astype(float)
    l = _to_series(low).astype(float)
    c = _to_series(close).astype(float)
    up_move = h.diff()
    down_move = -l.diff()
    plus_dm = pd.Series(np.where((up_move > down_move) & (up_move > 0), up_move, 0.0), index=h.index)
    minus_dm = pd.Series(np.where((down_move > up_move) & (down_move > 0), down_move, 0.0), index=h.index)
    tr = atr(h, l, c, period).replace(0.0, np.nan)
    plus_di = 100.0 * (plus_dm.rolling(period, min_periods=period).mean() / tr)
    minus_di = 100.0 * (minus_dm.rolling(period, min_periods=period).mean() / tr)
    denom = (plus_di + minus_di).replace(0.0, np.nan)
    dx = 100.0 * (plus_di - minus_di).abs() / denom
    return dx.rolling(window=period, min_periods=period).mean()

# ========= 内置策略 =========
def strategy_macd_rsi_bb(df: pd.DataFrame, cfg: Dict[str, Any] = None) -> Dict[str, pd.Series]:
    cfg = cfg or {}
    fast = cfg.get('macd_fast', 12); slow = cfg.get('macd_slow', 26); sig = cfg.get('macd_signal', 9)
    rsi_period = cfg.get('rsi_period', 14); bb_period = cfg.get('bb_period', 20); bb_std = cfg.get('bb_std', 2.0)
    macd_line, signal_line, _ = macd(df['close'], fast, slow, sig)
    r = rsi(df['close'], rsi_period)
    bb_u, bb_m, bb_l = bollinger_bands(df['close'], bb_period, bb_std)
    golden_cross = (macd_line > signal_line) & (macd_line.shift(1) <= signal_line.shift(1))
    death_cross = (macd_line < signal_line) & (macd_line.shift(1) >= signal_line.shift(1))
    long_entry = golden_cross & (r.shift(1) <= 30) & (r > 30) & (df['close'] >= bb_l)
    long_exit = death_cross | ((r.shift(1) >= 70) & (r < 70))
    short_entry = death_cross & (r.shift(1) >= 70) & (r < 70) & (df['close'] <= bb_u)
    short_exit = golden_cross | ((r.shift(1) <= 30) & (r > 30))
    return {k: v.fillna(False) for k, v in {
        'long_entry': long_entry, 'long_exit': long_exit,
        'short_entry': short_entry, 'short_exit': short_exit
    }.items()}

def strategy_kdj_ma_volume(df: pd.DataFrame, cfg: Dict[str, Any] = None) -> Dict[str, pd.Series]:
    cfg = cfg or {}
    k_period = cfg.get('k_period', 14); d_period = cfg.get('d_period', 3)
    ma_period = cfg.get('ma_period', 50); vol_mult = cfg.get('vol_mult', 1.2)
    k, d = stochastic(df['high'], df['low'], df['close'], k_period, d_period)
    ma = sma(df['close'], ma_period)
    vol_ma = sma(df['volume'], 20)
    k_cross_up = (k > d) & (k.shift(1) <= d.shift(1))
    k_cross_down = (k < d) & (k.shift(1) >= d.shift(1))
    strong_vol = df['volume'] > (vol_ma * vol_mult)
    long_entry = k_cross_up & (df['close'] > ma) & strong_vol
    long_exit = k_cross_down | (df['close'] < ma)
    short_entry = k_cross_down & (df['close'] < ma) & strong_vol
    short_exit = k_cross_up | (df['close'] > ma)
    return {k: v.fillna(False) for k, v in {
        'long_entry': long_entry, 'long_exit': long_exit,
        'short_entry': short_entry, 'short_exit': short_exit
    }.items()}

def strategy_adx_ema_rsi(df: pd.DataFrame, cfg: Dict[str, Any] = None) -> Dict[str, pd.Series]:
    cfg = cfg or {}
    adx_period = cfg.get('adx_period', 14); adx_thr = cfg.get('adx_thr', 25)
    ema_fast = cfg.get('ema_fast', 20); ema_slow = cfg.get('ema_slow', 50)
    rsi_period = cfg.get('rsi_period', 14); rsi_buy = cfg.get('rsi_buy', 55); rsi_sell = cfg.get('rsi_sell', 45)
    a = adx(df['high'], df['low'], df['close'], adx_period)
    ef = ema(df['close'], ema_fast)
    es = ema(df['close'], ema_slow)
    r = rsi(df['close'], rsi_period)
    trend_up = (ef > es) & (a > adx_thr)
    trend_down = (ef < es) & (a > adx_thr)
    long_entry = trend_up & (r > rsi_buy)
    long_exit = (ef < es) | (r < 50)
    short_entry = trend_down & (r < rsi_sell)
    short_exit = (ef > es) | (r > 50)
    return {k: v.fillna(False) for k, v in {
        'long_entry': long_entry, 'long_exit': long_exit,
        'short_entry': short_entry, 'short_exit': short_exit
    }.items()}

STRATEGY_REGISTRY: Dict[str, Callable[[pd.DataFrame, Dict[str, Any]], Dict[str, pd.Series]]] = {
    'macd_rsi_bb': strategy_macd_rsi_bb,
    'kdj_ma_volume': strategy_kdj_ma_volume,
    'adx_ema_rsi': strategy_adx_ema_rsi,
}

# ========= 外部策略自动加载 =========
def load_external_strategies() -> Dict[str, Callable[[pd.DataFrame, Dict[str, Any]], Dict[str, pd.Series]]]:
    patterns = ['策略*.py', 'strategy*.py', '*策略*.py']
    files: List[str] = []
    for pat in patterns:
        files.extend(glob.glob(pat))
    files = sorted({f for f in files if os.path.basename(f) != os.path.basename(__file__)})
    result: Dict[str, Callable] = {}
    probe_names = ['generate_signals', 'strategy', 'signals']
    for idx, path in enumerate(files):
        try:
            mod_name = f"extstrat_{idx}"
            mod = SourceFileLoader(mod_name, path).load_module()
            fn = None
            picked_name = None
            for name in probe_names:
                if hasattr(mod, name) and callable(getattr(mod, name)):
                    fn = getattr(mod, name)
                    picked_name = name
                    break
            if fn is None:
                continue
            def make_wrapper(func: Callable, fname: str) -> Callable[[pd.DataFrame, Dict[str, Any]], Dict[str, pd.Series]]:
                def wrapper(df: pd.DataFrame, cfg: Dict[str, Any] = None) -> Dict[str, pd.Series]:
                    sigs = func(df, cfg or {})
                    keys = ['long_entry','long_exit','short_entry','short_exit']
                    out: Dict[str, pd.Series] = {}
                    for k in keys:
                        v = sigs.get(k, pd.Series(False, index=df.index))
                        sv = _to_series(v).reindex(df.index).fillna(False).astype(bool)
                        out[k] = sv
                    return out
                wrapper.__name__ = f"{fname}_wrapped"
                return wrapper
            base = os.path.splitext(os.path.basename(path))[0]
            label = f"ext:{base}"
            label0 = label
            c = 1
            while label in result or label in STRATEGY_REGISTRY:
                label = f"{label0}_{c}"
                c += 1
            result[label] = make_wrapper(fn, picked_name)
        except Exception:
            continue
    return result

# ========= 数据获取（默认合约） =========
def fetch_ohlcv(exchange_id: str = 'okx',
                symbol: str = 'BTC-USDT-SWAP',
                timeframe: str = '1h',
                days: int = 60,
                limit: Optional[int] = None) -> pd.DataFrame:
    ex_class = getattr(ccxt, exchange_id)
    if exchange_id.lower() == 'binance':
        exchange = ex_class({'enableRateLimit': True, 'options': {'defaultType': 'swap'}})
    else:
        exchange = ex_class({'enableRateLimit': True})
    tf_to_min: Dict[str, int] = {'1m':1,'3m':3,'5m':5,'15m':15,'30m':30,'1h':60,'2h':120,'4h':240,'6h':360,'8h':480,'12h':720,'1d':1440}
    bars_est = days * (1440 // tf_to_min.get(timeframe, 60))
    eff_limit: int = int(min(max(bars_est, 200), 1500)) if not (isinstance(limit, int) and limit > 0) else int(limit)
    data = getattr(exchange, 'fetch_ohlcv')(symbol, timeframe=timeframe, limit=eff_limit)
    df = pd.DataFrame(data)
    if df.shape[1] >= 6:
        df.columns = ['timestamp','open','high','low','close','volume']
    else:
        needed = ['timestamp','open','high','low','close','volume']
        for i, col in enumerate(needed):
            if i < df.shape[1]:
                df.rename(columns={df.columns[i]: col}, inplace=True)
            else:
                df[col] = pd.NA
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', errors='coerce')
    return df

# ========= 回测引擎（含 手续费/资金费率/滑点） =========
def apply_strategy(df: pd.DataFrame, strat_fn: Callable[[pd.DataFrame, Dict[str, Any]], Dict[str, pd.Series]], cfg: Dict[str, Any]) -> Dict[str, pd.Series]:
    return strat_fn(df.copy(), cfg)

def run_backtest(df: pd.DataFrame,
                 signals: Dict[str, pd.Series],
                 timeframe: str,
                 mode: str = 'both',
                 sl_pct: Optional[float] = None,
                 tp_pct: Optional[float] = None,
                 fee_rate: float = 0.0005,
                 slippage_bp: float = 2.0,
                 funding_rate_8h: float = 0.0,
                 funding_direction: str = 'none'
                 ) -> Dict[str, Any]:
    df = df.copy()
    df[['long_entry','long_exit','short_entry','short_exit']] = pd.DataFrame({
        'long_entry': signals['long_entry'].astype(bool),
        'long_exit': signals['long_exit'].astype(bool),
        'short_entry': signals['short_entry'].astype(bool),
        'short_exit': signals['short_exit'].astype(bool),
    })
    bar_min = timeframe_to_minutes(timeframe)
    per_bar_funding = 0.0
    if funding_rate_8h and bar_min > 0:
        per_bar_funding = funding_rate_8h * (bar_min / 480.0)
    slip = (slippage_bp or 0.0) * 0.0001
    position: Optional[str] = None
    entry_price: Optional[float] = None
    equity: float = 1.0
    peak: float = 1.0
    max_dd: float = 0.0
    trades: List[Dict[str, Any]] = []

    def apply_fee(eq: float) -> float:
        return eq * (1.0 - fee_rate) if fee_rate > 0 else eq

    for i in range(1, len(df)):
        price_mid = float(df['close'].iloc[i])
        row = df.iloc[i]

        if position is not None and per_bar_funding != 0.0 and funding_direction in ('pay_long','pay_short'):
            if (position == 'long' and funding_direction == 'pay_long') or (position == 'short' and funding_direction == 'pay_short'):
                equity *= (1.0 - per_bar_funding)
            elif (position == 'long' and funding_direction == 'pay_short') or (position == 'short' and funding_direction == 'pay_long'):
                equity *= (1.0 + per_bar_funding)

        if position is not None and entry_price is not None and (sl_pct is not None or tp_pct is not None):
            if position == 'long':
                exec_price = price_mid * (1.0 - slip)
                ret = (exec_price / entry_price - 1.0)
            else:
                exec_price = price_mid * (1.0 + slip)
                ret = (entry_price / exec_price - 1.0)
            hit_tp = (tp_pct is not None and ret >= tp_pct)
            hit_sl = (sl_pct is not None and ret <= -sl_pct)
            if hit_tp or hit_sl:
                equity *= (1.0 + ret)
                equity = apply_fee(equity)
                trades.append({'side': position, 'entry': entry_price, 'exit': exec_price, 'ret': ret, 'reason': 'tp' if hit_tp else 'sl'})
                position, entry_price = None, None
                peak = max(peak, equity); max_dd = max(max_dd, (peak - equity)/peak)
                continue

        if position == 'long' and bool(row['long_exit']):
            exec_price = price_mid * (1.0 - slip)
            r = exec_price / entry_price - 1.0
            equity *= (1.0 + r)
            equity = apply_fee(equity)
            trades.append({'side': 'long', 'entry': entry_price, 'exit': exec_price, 'ret': r, 'reason': 'signal'})
            position, entry_price = None, None
        elif position == 'short' and bool(row['short_exit']):
            exec_price = price_mid * (1.0 + slip)
            r = entry_price / exec_price - 1.0
            equity *= (1.0 + r)
            equity = apply_fee(equity)
            trades.append({'side': 'short', 'entry': entry_price, 'exit': exec_price, 'ret': r, 'reason': 'signal'})
            position, entry_price = None, None

        if position is None:
            if bool(row['long_entry']) and mode in ('both','long'):
                entry_price = price_mid * (1.0 + slip)
                position = 'long'
                equity = apply_fee(equity)
            elif bool(row['short_entry']) and mode == 'both':
                entry_price = price_mid * (1.0 - slip)
                position = 'short'
                equity = apply_fee(equity)

        peak = max(peak, equity)
        max_dd = max(max_dd, (peak - equity)/peak)

    if position is not None and entry_price is not None:
        last_mid = float(df['close'].iloc[-1])
        if position == 'long':
            exec_price = last_mid * (1.0 - slip)
            r = exec_price / entry_price - 1.0
        else:
            exec_price = last_mid * (1.0 + slip)
            r = entry_price / exec_price - 1.0
        equity *= (1.0 + r)
        equity = apply_fee(equity)
        trades.append({'side': position, 'entry': entry_price, 'exit': exec_price, 'ret': r, 'reason': 'close'})

    rets = [t['ret'] for t in trades]
    wins = sum(1 for r in rets if r > 0)
    losses = sum(1 for r in rets if r <= 0)
    pf = (sum(r for r in rets if r > 0) / abs(sum(r for r in rets if r <= 0))) if losses > 0 else float('inf')
    win_rate = (wins / len(rets) * 100) if rets else 0.0

    return {
        'final_equity': equity,
        'total_return_pct': (equity - 1.0)*100,
        'num_trades': len(rets),
        'win_rate_pct': win_rate,
        'profit_factor': pf,
        'max_drawdown_pct': max_dd * 100,
        'trades': trades
    }

# ========= 命令行入口 =========
def main():
    parser = argparse.ArgumentParser(description="Single-cell futures/swap backtester for Colab")
    parser.add_argument('--exchange', type=str, default='okx', help='ccxt exchange id (e.g., okx/binance)')
    parser.add_argument('--symbols', type=str, default='', help='comma separated contract symbols')
    parser.add_argument('--symbols_source', type=str, default='main.py', help='file to parse symbols from (default: main.py)')
    parser.add_argument('--timeframe', type=str, default='1h')
    parser.add_argument('--days', type=int, default=60)
    parser.add_argument('--strategy', type=str, default='all', help='all or a specific strategy name (internal or ext:xxx)')
    parser.add_argument('--mode', type=str, default='both', choices=['both','long'])
    parser.add_argument('--sl', type=float, default=None, help='stop loss percent, e.g. 0.03 for 3%')
    parser.add_argument('--tp', type=float, default=None, help='take profit percent, e.g. 0.06 for 6%')
    parser.add_argument('--fee_rate', type=float, default=0.0005, help='per-side fee rate, e.g. 0.0005')
    parser.add_argument('--slippage_bp', type=float, default=2.0, help='slippage in basis points per trade (adverse), e.g. 2.0')
    parser.add_argument('--funding_rate_8h', type=float, default=0.0, help='funding rate per 8h, e.g. 0.0001')
    parser.add_argument('--funding_direction', type=str, default='none', choices=['pay_long','pay_short','none'], help='who pays funding')
    args = parser.parse_args()

    # 合约列表
    symbols: List[str] = []
    if args.symbols_source:
        symbols = parse_symbols_from_file(args.symbols_source)
    if not symbols and args.symbols:
        symbols = [s.strip() for s in args.symbols.split(',') if s.strip()]
    if not symbols:
        symbols = ['BTC-USDT-SWAP','ETH-USDT-SWAP']

    # 汇总策略：内置 + 外部
    external = load_external_strategies()
    all_strats: Dict[str, Callable] = {**STRATEGY_REGISTRY, **external}

    # 选择策略
    if args.strategy == 'all':
        strat_items = list(all_strats.items())
    else:
        if args.strategy in all_strats:
            strat_items = [(args.strategy, all_strats[args.strategy])]
        else:
            strat_items = [(k, v) for k, v in all_strats.items() if k.endswith(args.strategy)] or list(all_strats.items())

    print(f"Backtesting strategies={[k for k,_ in strat_items]} on {symbols} | {args.exchange} {args.timeframe} last {args.days}d")
    all_reports: List[str] = []
    ts = datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')

    for strat_name, strategy_fn in strat_items:
        print(f"\n== Strategy: {strat_name} ==")
        header = f"Strategy: {strat_name}, Exchange: {args.exchange}, TF: {args.timeframe}, Days: {args.days}, Fee: {args.fee_rate}, Slip(bp): {args.slippage_bp}, Funding/8h: {args.funding_rate_8h}, Dir: {args.funding_direction}"
        lines = [header]
        for sym in symbols:
            df = fetch_ohlcv(args.exchange, sym, args.timeframe, args.days)
            if len(df) < 200:
                msg = f"- {sym}: insufficient bars ({len(df)})"
                print(msg); lines.append(msg); continue
            sigs = apply_strategy(df, strategy_fn, cfg={})
            result = run_backtest(
                df, sigs, timeframe=args.timeframe, mode=args.mode,
                sl_pct=args.sl, tp_pct=args.tp,
                fee_rate=args.fee_rate, slippage_bp=args.slippage_bp,
                funding_rate_8h=args.funding_rate_8h, funding_direction=args.funding_direction
            )
            print(f"- {sym}: ret={result['total_return_pct']:.2f}%, trades={result['num_trades']}, win={result['win_rate_pct']:.1f}%, pf={result['profit_factor']:.2f}, mdd={result['max_drawdown_pct']:.2f}%")
            lines.append(f"{sym}: ret={result['total_return_pct']:.2f}%, trades={result['num_trades']}, win={result['win_rate_pct']:.1f}%, pf={result['profit_factor']:.2f}, mdd={result['max_drawdown_pct']:.2f}%")
        report = "\n".join(lines)
        out_file = f"backtest_report_{strat_name}_{ts}.txt"
        with open(out_file, 'w', encoding='utf-8') as f:
            f.write(report)
        print(f"Saved report to: {out_file}")
        all_reports.append(out_file)

    index_file = f"backtest_reports_{ts}.txt"
    with open(index_file, 'w', encoding='utf-8') as f:
        f.write("\n".join(all_reports))
    print(f"\nAll reports index: {index_file}")

if __name__ == "__main__":
    main()
'''
with open('colab_futures_backtest.py', 'w', encoding='utf-8') as f:
    f.write(script)
print("colab_futures_backtest.py written.")

# [单元格 3] 运行示例（Colab 前缀 !python；本地终端直接 python）
!python colab_futures_backtest.py \
  --exchange okx \
  --symbols_source main.py \
  --timeframe 1h \
  --days 60 \
  --strategy all \
  --mode both \
  --sl 0.03 \
  --tp 0.06 \
  --fee_rate 0.0005 \
  --slippage_bp 2.0 \
  --funding_rate_8h 0.0001 \
  --funding_direction pay_long

# 说明：
# - 在本地 PowerShell 中运行时，将三段分别改为：
#   1) pip install ccxt pandas numpy
#   2) 用 PowerShell Here-String 写文件：
#      @'
#      （将上面的 script 三引号内内容原样粘贴）
#      '@ | Set-Content -Encoding UTF8 colab_futures_backtest.py
#   3) python colab_futures_backtest.py --exchange okx ...（其余参数同上）

# ========= 组合策略优化方案 =========
# 问题分析：组合策略（如"高盈利+高胜率+..."）可能出现零交易问题
# 原因：AND 条件过于严格，多个策略信号难以同时满足

# 优化方案：
# 1. 放宽进入条件：使用多数投票机制（>50%策略确认即可）
# 2. 时间窗口确认：允许信号在N个K线内先后出现都算有效
# 3. 权重评分：根据各策略历史表现分配不同权重
# 4. 阈值调整：降低单个策略的触发阈值

# 示例改进代码（在外部策略文件中实现）：
'''
def generate_signals_combined_optimized(df, cfg=None):
    # 获取各子策略信号
    signals_list = []
    for strat_name in ['strategy_a', 'strategy_b', 'strategy_c']:
        sigs = STRATEGY_REGISTRY[strat_name](df, cfg)
        signals_list.append(sigs)
    
    # 多数投票机制（>50%策略确认）
    long_entry_votes = sum(1 for sigs in signals_list if sigs['long_entry'].iloc[-1])
    short_entry_votes = sum(1 for sigs in signals_list if sigs['short_entry'].iloc[-1])
    
    long_entry = long_entry_votes >= len(signals_list) * 0.5  # 50%以上确认
    short_entry = short_entry_votes >= len(signals_list) * 0.5
    
    # 退出条件保持宽松（OR逻辑）
    long_exit = any(sigs['long_exit'].iloc[-1] for sigs in signals_list)
    short_exit = any(sigs['short_exit'].iloc[-1] for sigs in signals_list)
    
    return {
        'long_entry': pd.Series([long_entry] * len(df), index=df.index),
        'long_exit': pd.Series([long_exit] * len(df), index=df.index),
        'short_entry': pd.Series([short_entry] * len(df), index=df.index),
        'short_exit': pd.Series([short_exit] * len(df), index=df.index)
    }
'''

# ========= 实际回测结果分析 =========
# 基于近期回测数据（2025年10月7日）的性能总结：

# 表现最佳的策略：
# - 趋势回调_布林带_RSI：BTC-USDT-SWAP 30天胜率100.0%，收益0.90%（交易6次）
# - ATR突破：BNB-USDT-SWAP 30天胜率62.5%，收益10.45%（交易8次）
# - 布林带_RSI：SOL-USDT-SWAP 30天胜率77.8%，收益2.90%（交易9次）

# 组合策略问题分析：
# - 高胜率+高盈利率组合：胜率33.3%-57.1%，收益-2.60%到0.25%
# - 高盈利+高胜率+各种指标：所有组合均为0交易，需要优化信号生成逻辑
# - 单一策略表现优于组合策略，需要重新设计组合逻辑

# ========= 性能分析与优化建议 =========
# 回测结果解读指南：
# - 胜率 > 50%：策略有正向预期
# - 盈亏比 > 1.2：风险收益比合理  
# - 最大回撤 < 20%：风险控制良好
# - 交易次数 > 10：统计意义充分

# 关键优化方向：
# 1. 组合策略信号优化：使用多数投票机制替代严格AND条件
# 2. 参数调优：针对表现最佳的策略进行深度参数优化
# 3. 过滤条件：添加成交量过滤、波动率过滤提升信号质量
# 4. 止损优化：使用ATR动态止损替代固定百分比止损
# 5. 资金费率优化：针对永续合约优化资金费率处理逻辑

# 紧急修复方案：
# 对于零交易组合策略，建议：
# - 放宽进入条件：使用>50%策略确认即可开仓
# - 时间窗口确认：允许信号在3-5个K线内先后出现
# - 权重评分：根据各策略历史表现分配不同权重

# ========= 更多使用示例 =========
# 示例1：只做多策略测试
# !python colab_futures_backtest.py --strategy macd_rsi_bb --mode long --days 90

# 示例2：高风险策略（提高止损止盈）
# !python colab_futures_backtest.py --strategy kdj_ma_volume --sl 0.05 --tp 0.10

# 示例3：低手续费环境测试  
# !python colab_futures_backtest.py --fee_rate 0.0002 --slippage_bp 1.0

# 示例4：多交易所对比
# !python colab_futures_backtest.py --exchange binance --symbols BTCUSDT,ETHUSDT